use clap::*;
use phylotree::tree::{Node, NodeId, Tree};

// Create clap subcommand arguments
pub fn make_subcommand() -> Command {
    Command::new("tex")
        .about("Visualize the Newick tree via LaTeX")
        .after_help(
            r###"
* Styles are stored in the comments of each node

* To convert the .tex files generated by this command to pdf,
  you need to install LaTeX and some additional packages
    * `XeLaTeX` and `latexmk` for compiling unicode .tex
    * `xeCJK` for East Asian characters
    * `Forest` is a `TikZ`-based package for drawing trees

nwr tex test.nwk -o test.tex
latexmk -xelatex test.tex
latexmk -c test.tex

"###,
        )
        .arg(
            Arg::new("infile")
                .required(true)
                .num_args(1)
                .index(1)
                .help("Input filename. [stdin] for standard input"),
        )
        .arg(
            Arg::new("bare")
                .long("bare")
                .action(ArgAction::SetTrue)
                .help("Only forest code, no full template"),
        )
        .arg(
            Arg::new("outfile")
                .short('o')
                .long("outfile")
                .num_args(1)
                .default_value("stdout")
                .help("Output filename. [stdout] for screen"),
        )
}

// command implementation
pub fn execute(args: &ArgMatches) -> anyhow::Result<()> {
    let mut writer = intspan::writer(args.get_one::<String>("outfile").unwrap());
    let is_bare = args.get_flag("bare");

    let infile = args.get_one::<String>("infile").unwrap();
    let tree = nwr::read_newick(infile);

    let out_string = format_forest(&tree);

    if is_bare {
        writer.write_all((out_string + "\n").as_ref())?;
    } else {
        static FILE_TEMPLATE: &str = include_str!("../../doc/template.tex");
        let mut template = FILE_TEMPLATE.to_string();

        let begin = template.find("%BEGIN").unwrap();
        let end = template.find("%END").unwrap();
        template.replace_range(begin..end, &out_string);

        writer.write_all(template.as_ref())?;
    }

    Ok(())
}

fn format_forest(tree: &Tree) -> String {
    let root = tree.get_root().unwrap();
    format_sub_forest(tree, &root)
}

fn format_sub_forest(tree: &Tree, id: &NodeId) -> String {
    let node = tree.get(id).unwrap();
    let indent = "  ";

    let children = &node.children;
    let depth = node.get_depth();

    if children.is_empty() {
        let indention = indent.repeat(depth);
        format!("{}[{}]\n", indention, format_node(tree, id))
    } else {
        let branch_set = children
            .iter()
            .map(|child| format_sub_forest(tree, child))
            .collect::<Vec<_>>();

        let indention = indent.repeat(depth);
        format!(
            "{}[{}\n{}{}]\n",
            indention,
            format_node(tree, id),
            branch_set.join(""),
            indention,
        )
    }
}

fn format_node(tree: &Tree, id: &NodeId) -> String {
    let node = tree.get(id).unwrap();
    let depth = node.get_depth();

    let mut repr = String::new();
    if let Some(name) = node.name.clone() {
        repr += &format!("{{{}}},", &name);
    } else {
        if node.is_tip() {
            repr += "{~},"; // non-breaking space in latex
        } else {
            repr += ",";
        }
    }
    // if let Some(parent_edge) = node.parent_edge {
    //     repr += &format!(":{}", &parent_edge);
    // }
    if let Some(comment) = node.comment.clone() {
        repr += &format!(" comment={{{}}},", &comment);
    }

    let tier = if node.is_tip() {
        0
    } else {
        branch_depth(tree, id) - depth
    };
    repr += &format!(" tier={},", tier);

    repr
}

// max depth of this node's children
fn branch_depth(tree: &Tree, id: &NodeId) -> usize {
    tree.get_descendants(id)
        .unwrap()
        .iter()
        .map(|e| tree.get(e).unwrap().get_depth())
        .max()
        .unwrap()
}
