use clap::*;
use phylotree::tree::{Edge, NodeId, Tree};

// Create clap subcommand arguments
pub fn make_subcommand() -> Command {
    Command::new("tex")
        .about("Visualize the Newick tree via LaTeX")
        .after_help(
            r###"
* Styles are stored in the comments of each node

* Drawing a cladogram by default
* Set `--bl` to draw a phylogenetic tree

* To convert the .tex files generated by this command to pdf,
  you need to install LaTeX and some additional packages
    * `XeLaTeX` and `latexmk` for compiling unicode .tex
    * `xeCJK` for East Asian characters
    * `Forest` is a `TikZ`-based package for drawing trees

nwr tex test.nwk -o test.tex
latexmk -xelatex test.tex
latexmk -c test.tex

"###,
        )
        .arg(
            Arg::new("infile")
                .required(true)
                .num_args(1)
                .index(1)
                .help("Input filename. [stdin] for standard input"),
        )
        .arg(
            Arg::new("bare")
                .long("bare")
                .action(ArgAction::SetTrue)
                .help("Only forest code, no full template"),
        )
        .arg(
            Arg::new("bl")
                .long("bl")
                .action(ArgAction::SetTrue)
                .help("With branch lengths"),
        )
        .arg(
            Arg::new("outfile")
                .short('o')
                .long("outfile")
                .num_args(1)
                .default_value("stdout")
                .help("Output filename. [stdout] for screen"),
        )
}

// command implementation
pub fn execute(args: &ArgMatches) -> anyhow::Result<()> {
    let mut writer = intspan::writer(args.get_one::<String>("outfile").unwrap());
    let is_bare = args.get_flag("bare");
    let is_bl = args.get_flag("bl");

    let infile = args.get_one::<String>("infile").unwrap();
    let tree = nwr::read_newick(infile);

    let height = if is_bl { tree.height().unwrap() } else { 0.0 };
    // eprintln!("height = {:#?}", height);

    let mut out_string = format_forest(&tree, height);

    // a bar of unit length
    if is_bl {
        let bar_len = format!("{:.3}", height / 100.0 * 10.0);
        // a grey 1pt bar
        out_string += "\\draw[-, grey, line width=1pt]";
        // bar position
        out_string += " ($(current bounding box.south east)+(-10mm,-2mm)$)";
        // 10 mm
        out_string += " --++ (-10mm,0mm)";
        // text
        out_string += &format!(" node[midway, below]{{\\scriptsize{{{}}}}};\n", &bar_len);
    }

    if is_bare {
        writer.write_all((out_string + "\n").as_ref())?;
    } else {
        static FILE_TEMPLATE: &str = include_str!("../../doc/template.tex");
        let mut template = FILE_TEMPLATE.to_string();

        let begin = template.find("%BEGIN").unwrap();
        let end = template.find("%END").unwrap();
        template.replace_range(begin..end, &out_string);

        writer.write_all(template.as_ref())?;
    }

    Ok(())
}

fn format_forest(tree: &Tree, height: Edge) -> String {
    let root = tree.get_root().unwrap();
    format_sub_forest(tree, &root, height)
}

fn format_sub_forest(tree: &Tree, id: &NodeId, height: Edge) -> String {
    let node = tree.get(id).unwrap();
    let indent = "  ";

    let children = &node.children;
    let depth = node.get_depth();

    if children.is_empty() {
        let indention = indent.repeat(depth);
        format!("{}[{}]\n", indention, format_node(tree, id, height))
    } else {
        let branch_set = children
            .iter()
            .map(|child| format_sub_forest(tree, child, height))
            .collect::<Vec<_>>();

        let indention = indent.repeat(depth);
        format!(
            "{}[{}\n{}{}]\n",
            indention,
            format_node(tree, id, height),
            branch_set.join(""),
            indention,
        )
    }
}

fn format_node(tree: &Tree, id: &NodeId, height: Edge) -> String {
    let node = tree.get(id).unwrap();
    let depth = node.get_depth();

    let mut repr = String::new();
    if let Some(name) = node.name.clone() {
        repr += &format!("{{{}}},", &name);
    } else {
        if node.is_tip() {
            repr += "{~},"; // non-breaking space in latex
        } else {
            repr += ",";
        }
    }

    if let Some(comment) = node.comment.clone() {
        repr += &format!(" comment={{{}}},", &comment);
    }

    if height == 0.0 {
        let tier = if node.is_tip() {
            0
        } else {
            branch_depth(tree, id) - depth
        };
        repr += &format!(" tier={},", tier);
    } else {
        let edge = match node.parent_edge.clone() {
            None => 0.0,
            Some(e) => e,
        };
        let bl = calc_length(edge, height);
        repr += &format!(" l={}mm, l sep=0,", bl);

        if node.is_tip() {
            // Add an invisible node to the rightmost to occupy spaces
            repr += " [{~},tier=0,edge={draw=none}],";
        }
    }

    repr
}

// max depth of this node's children
fn branch_depth(tree: &Tree, id: &NodeId) -> usize {
    tree.get_descendants(id)
        .unwrap()
        .iter()
        .map(|e| tree.get(e).unwrap().get_depth())
        .max()
        .unwrap()
}

//
fn calc_length(edge: Edge, height: Edge) -> i32 {
    (edge * 100.0 / height).round() as i32
}
